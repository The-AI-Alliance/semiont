#!/usr/bin/env node

/**
 * Build all packages in dependency order with proper error handling
 *
 * Build order (SPEC-FIRST ARCHITECTURE):
 * 1. @semiont/core - Core event types and utilities - NO DEPENDENCIES
 * 2. @semiont/api-client - Generates types from openapi.json (spec-first) - depends on @semiont/core for ResourceEvent
 * 3. @semiont/ontology - Entity types, tag schemas, vocabularies (depends on @semiont/api-client only)
 * 4. @semiont/content - Content-addressed storage (depends on @semiont/core only)
 * 5. @semiont/event-sourcing - Event sourcing infrastructure (depends on @semiont/core and @semiont/api-client)
 * 6. @semiont/jobs - Job queue and worker infrastructure (depends on @semiont/core and @semiont/api-client)
 * 7. @semiont/graph - Graph database abstraction (depends on @semiont/core, @semiont/api-client, and @semiont/ontology)
 * 8. @semiont/inference - AI inference for entity extraction and text generation (depends on @semiont/core and @semiont/api-client)
 * 9. @semiont/make-meaning - Context assembly, pattern detection, and relationship reasoning (depends on @semiont/inference, @semiont/graph, @semiont/ontology)
 * 10. @semiont/react-ui - React components and hooks for Semiont applications (depends on @semiont/api-client, @semiont/ontology)
 * 11. Backend - Consumes types from @semiont/api-client, @semiont/core, @semiont/ontology, @semiont/content, @semiont/event-sourcing, @semiont/jobs, @semiont/graph, @semiont/inference, and @semiont/make-meaning
 * 12. @semiont/test-utils - Testing utilities
 * 13. @semiont/mcp-server - MCP server (depends on @semiont/api-client)
 */

const { execSync } = require('child_process');
const path = require('path');
const fs = require('fs');

// CRITICAL: Bundle OpenAPI spec from specs/src/ BEFORE building
// In spec-first architecture, specs/src/openapi.json is the source of truth
// specs/openapi.json is generated by bundling
console.log('üì¶ Bundling OpenAPI spec from specs/src/...');
try {
  execSync('npm run openapi:bundle', {
    stdio: 'inherit',
    cwd: path.join(__dirname, '..')
  });
  console.log('‚úÖ OpenAPI spec bundled successfully\n');
} catch (error) {
  console.error('‚ùå Failed to bundle OpenAPI spec:', error.message);
  process.exit(1);
}

// Note: api-client's prebuild script will copy the bundled spec
// No need to copy it here manually

const buildSteps = [
  {
    name: '@semiont/api-client',
    type: 'package',
    description: 'API client (generates types from openapi.json - SPEC-FIRST)'
  },
  {
    name: '@semiont/ontology',
    type: 'package',
    description: 'Domain ontology (entity types, tag schemas, vocabularies)'
  },
  {
    name: '@semiont/core',
    type: 'package',
    description: 'Core SDK package (depends on @semiont/api-client and @semiont/ontology)'
  },
  {
    name: '@semiont/content',
    type: 'package',
    description: 'Content-addressed storage for representations (depends on @semiont/core)'
  },
  {
    name: '@semiont/event-sourcing',
    type: 'package',
    description: 'Event sourcing infrastructure (depends on @semiont/core and @semiont/api-client)'
  },
  {
    name: '@semiont/jobs',
    type: 'package',
    description: 'Job queue and worker infrastructure (depends on @semiont/core and @semiont/api-client)'
  },
  {
    name: '@semiont/graph',
    type: 'package',
    description: 'Graph database abstraction (depends on @semiont/core and @semiont/api-client)'
  },
  {
    name: '@semiont/inference',
    type: 'package',
    description: 'AI inference for entity extraction and text generation (depends on @semiont/core and @semiont/api-client)'
  },
  {
    name: '@semiont/make-meaning',
    type: 'package',
    description: 'Context assembly, pattern detection, and relationship reasoning (depends on @semiont/inference, @semiont/graph, @semiont/ontology)'
  },
  {
    name: '@semiont/react-ui',
    type: 'package',
    description: 'React components and hooks for Semiont applications (depends on @semiont/api-client, @semiont/ontology)'
  },
  {
    name: 'semiont-backend',
    type: 'app',
    description: 'Backend (consumes types from @semiont/api-client)',
  },
  {
    name: '@semiont/test-utils',
    type: 'package',
    description: 'Test utilities'
  },
  {
    name: '@semiont/mcp-server',
    type: 'package',
    description: 'MCP server'
  }
];

console.log('üèóÔ∏è  Building packages and apps in dependency order...\n');

for (const step of buildSteps) {
  console.log(`üì¶ Building ${step.name}... (${step.description})`);

  try {
    // Check if package/app exists
    const basePath = step.type === 'package'
      ? path.join(__dirname, '..', 'packages', step.name.replace('@semiont/', ''))
      : path.join(__dirname, '..', 'apps', step.name.replace('semiont-', ''));

    if (!fs.existsSync(basePath)) {
      console.error(`‚ùå Directory not found: ${basePath}`);
      process.exit(1);
    }

    // Check if package.json exists and has build script
    const pkgJsonPath = path.join(basePath, 'package.json');
    if (!fs.existsSync(pkgJsonPath)) {
      console.error(`‚ùå package.json not found: ${pkgJsonPath}`);
      process.exit(1);
    }

    const pkgJson = JSON.parse(fs.readFileSync(pkgJsonPath, 'utf8'));
    if (!pkgJson.scripts?.build) {
      console.error(`‚ùå No build script found in ${step.name}`);
      process.exit(1);
    }

    // For api-client, it will bundle and copy the spec in its prebuild script
    // No additional verification needed here

    // Build the package/app
    execSync(`npm run build --workspace=${step.name}`, {
      stdio: 'inherit',
      cwd: path.join(__dirname, '..')
    });

    console.log(`‚úÖ ${step.name} built successfully\n`);

  } catch (error) {
    console.error(`‚ùå Failed to build ${step.name}:`);
    console.error(error.message);
    process.exit(1);
  }
}

console.log('üéâ All packages and apps built successfully!');
